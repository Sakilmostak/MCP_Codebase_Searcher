# Debugging Plan: MCP Codebase Searcher

## 1. Introduction
This plan outlines steps to debug and resolve issues identified in `potential_bugs_log.txt` and `task_master_test_plan.txt` for the `mcp-codebase-searcher` package. The primary source files for investigation are located in the `src/` directory:
- `mcp_searcher.py`: Main CLI entry point, argument parsing, top-level logic for `search` and `elaborate`.
- `mcp_search.py`: Core search logic (class `Searcher`).
- `file_scanner.py`: File discovery and filtering (class `FileScanner`).
- `output_generator.py`: Formatting search results (class `OutputGenerator`).
- `mcp_elaborate.py`: Contains `ContextAnalyzer` used for elaboration.
- `report_elaborator.py`: Core logic for elaborating on findings (function `elaborate_finding`).
- `config.py`: Module related to configuration, possibly API keys, source of import warnings.

The goal is to systematically address each bug, understand its root cause, implement a fix, and verify the solution.

## 2. Priority Issues & Debugging Steps

### Issue 1: Persistent '.config' Module Import Warning (Bug 5)
   - **Severity:** Critical (affects user perception, potentially masks other issues).
   - **Symptoms:** `Warning: Could not import '.'config' module... Error: attempted relative import with no known parent package` appears with many commands.
   - **Likely Affected File(s):** `src/config.py`, `src/mcp_searcher.py` (and any other files attempting to import `config.py`), `pyproject.toml` (packaging).
   - **Debugging Actions:**
     1.  **Understand `src/config.py` Purpose:**
         - Review `src/config.py`. What is its intended functionality? Is it for default settings, API key loading, or development-time overrides?
         - Does it contain code that runs on import and might cause issues or attempt relative imports itself?
     2.  **Examine Import Statements:**
         - Search the codebase (especially `src/mcp_searcher.py` and other top-level scripts if any) for how `config` or `src.config` is being imported.
         - The error "attempted relative import with no known parent package" is a strong indicator of an incorrect import like `from . import config` or `from .config import ...` in a script that is executed as the main entry point of the program.
         - **Hypothesis & Test:** If `mcp_searcher.py` (or another entry script) uses such a relative import for `config.py`, change it to an absolute import.
           - If `src` is the package root and `mcp_codebase_searcher` is the package name: `from mcp_codebase_searcher import config` (if `config.py` is at `src/config.py` and `src` is in `sys.path` or `mcp_codebase_searcher` refers to `src`).
           - Or, if the package is structured such that `mcp_codebase_searcher` is a directory within `src` (e.g. `src/mcp_codebase_searcher/config.py`), then it might be `from mcp_codebase_searcher.config import ...`. The actual structure as per the file listing (`src/config.py`) suggests `config.py` is a top-level module within the `src` directory.
     3.  **Check Packaging (`pyproject.toml`):**
         - How is the `src` directory treated during packaging? Are modules under `src` correctly mapped to the package namespace (e.g., `mcp_codebase_searcher.config`)?
         - Ensure `config.py` is included in the package if it's essential at runtime and that its path is resolvable.
         - For an `src` layout, `pyproject.toml` often specifies `package_dir = {"" = "src"}`.
     4.  **Isolate the Import:**
         - In `venv_editable_test` (with the package installed via `pip install -e .`), create a minimal Python script outside the `src` directory that does `import mcp_codebase_searcher` and then attempts to access the config module in the way the main application does. This can help reproduce the warning in isolation.
     5.  **Refactor `config.py` Usage / Relocation:**
         - Consider if `config.py` should be renamed or moved if its name conflicts with a standard library or another module.
         - If `config.py`'s primary role is to be imported by other modules *within* the package, ensure it doesn't contain code that assumes it's a top-level script or makes problematic relative imports.
         - If its purpose is only for development (e.g., local API keys not meant to be packaged), it should not be imported by packaged code in a way that breaks.

### Issue 2: `elaborate` Command API Key and Error Handling (Bugs 2, 3, 4)

   - **Bug 3: `elaborate` succeeds when API key should be "not found".**
     - **Severity:** High (security/predictability concern).
     - **Symptoms:** API key is picked up from an unexpected/unintended source during tests designed to have no key available.
     - **Likely Affected File(s):** `src/mcp_searcher.py` (API key resolution logic in `elaborate` block), `src/report_elaborator.py` (function `elaborate_finding`), `src/mcp_elaborate.py` (class `ContextAnalyzer`), `src/config.py`.
     - **Debugging Actions:**
       1.  **Trace API Key Discovery Path:** Add detailed logging (print statements or `logging` module) in `src/mcp_searcher.py` within the `elaborate` command's logic to show:
           - Value of `args.api_key`.
           - If `args.config_file` is checked, what key is found (or not).
           - If environment variables (e.g., `GOOGLE_API_KEY`) are checked.
           - If `src/config.py` is consulted.
           - The exact key value being passed to `elaborate_finding`.
       2.  **Review `python-dotenv` Usage:** If `python-dotenv` is used (explicitly or implicitly by a framework), verify:
           - Where `load_dotenv()` is called.
           - The path it's using (CWD, script directory, etc.).
           - Whether it searches parent directories (`find_dotenv()`). This could explain finding `.env` files outside the CWD.
       3.  **Inspect `ContextAnalyzer` Initialization:** In `src/mcp_elaborate.py`, how `ContextAnalyzer` receives and stores the API key. In `src/report_elaborator.py`, ensure `elaborate_finding` correctly passes the resolved key.
       4.  **Controlled Test Environment:** When re-testing "key not found":
           - Explicitly `unset GOOGLE_API_KEY` (and other relevant env vars).
           - Run from a directory confirmed to have no `.env` files.
           - Do not provide `--api-key` or `--config-file`.
       5.  **Refine & Document Precedence:** Make the API key lookup order strictly defined and documented. Consider limiting `.env` search to CWD or disabling parent directory search if that's the cause.

   - **Bug 2: Incorrect error for malformed JSON report file.**
     - **Severity:** Medium (hinders debugging).
     - **Symptoms:** `elaborate` reports "file not found" for an existing but malformed JSON file.
     - **Likely Affected File(s):** `src/mcp_searcher.py` (file reading/parsing in `elaborate` block).
     - **Debugging Actions:**
       1.  **Locate JSON Parsing:** In `src/mcp_searcher.py`, find where the `--report-file` is opened and `json.load()` (or `json.loads()`) is called.
       2.  **Implement Specific Exception Handling:** Wrap the `json.load()` call in a `try...except json.JSONDecodeError as e:` block.
       3.  **User-Friendly Error:** If `JSONDecodeError` is caught, print a specific error like "Error: Report file '{args.report_file}' is malformed or not valid JSON. Details: {e}" and `sys.exit(1)`. This should come after the `FileNotFoundError` check.

   - **Bug 4: `elaborate` command returns exit code 0 with invalid API key.**
     - **Severity:** Medium (bad for scripting).
     - **Symptoms:** Prints an API error/warning but exits with 0.
     - **Likely Affected File(s):** `src/mcp_searcher.py` (main `elaborate` logic), `src/report_elaborator.py`.
     - **Debugging Actions:**
       1.  **Trace Error Propagation:** The error "API key not valid" originates from `ContextAnalyzer` or the Gemini client. Ensure this error condition is reliably passed from `elaborate_finding` (in `report_elaborator.py`) back to the main `elaborate` block in `src/mcp_searcher.py`.
       2.  **Conditional Exit Code:** In `src/mcp_searcher.py`, if `elaborate_finding` indicates failure (e.g., by returning a specific error status/object, or raising an exception that's caught), then call `sys.exit(1)`.
          ```python
          # Example in mcp_searcher.py
          elaboration_result = elaborate_finding(...)
          print(elaboration_result) # Prints the error message from elaborate_finding
          if elaboration_result.startswith("Error:"): # Or a more robust error check
              sys.exit(1)
          ```

### Issue 3: Search: `no_results.json` File Not Created (Bug 1)
   - **Severity:** Medium (inconsistent behavior for users).
   - **Symptoms:** If a search yields no matches, the JSON output file specified by `--output-file` is not created.
   - **Likely Affected File(s):** `src/mcp_searcher.py` (search command logic, output file handling), `src/output_generator.py`.
   - **Debugging Actions:**
     1.  **Review Output Logic in `src/mcp_searcher.py`:**
         - Examine the flow for the `search` command, specifically how `results` are processed and when the `--output-file` is written.
         - The current logic likely exits or skips file writing if `results` is empty.
     2.  **Ensure `OutputGenerator` Handles Empty Results:**
         - In `src/output_generator.py`, verify that `OutputGenerator.generate_output([])` (an empty list of results) correctly returns the string representation of an empty JSON array (`'[]'`).
         - Add a unit test for this specific case in `OutputGenerator`.
     3.  **Modify File Writing Flow in `src/mcp_searcher.py`:**
         - The call to `output_gen.generate_output(results)` should happen regardless of whether `results` is empty.
         - The file specified by `--output-file` should always be opened and written to if the argument is provided.
         - **Revised Logic Sketch:**
           ```python
           # (inside search command block in mcp_searcher.py)
           # ... perform search, populate 'results' list ...

           output_gen = OutputGenerator(output_format=args.output_format)
           # This must handle empty 'results' correctly for each format.
           formatted_output = output_gen.generate_output(results)

           if args.output_file:
               try:
                   with open(args.output_file, 'w', encoding='utf-8') as f:
                       f.write(formatted_output)
                   # Optionally, inform the user if the file is empty due to no matches.
                   if not results:
                       print(f"No matches found. Empty report saved to {args.output_file}")
                   else:
                       print(f"Output successfully saved to {args.output_file}")
               except IOError as e:
                   print(f"Error: Could not write to output file '{args.output_file}': {e}", file=sys.stderr)
                   # Optionally print to console as fallback if not already doing so
                   if args.output_format != 'console' or not results: # Avoid double printing if console was primary and had results
                       print("\n--- Outputting to Console as Fallback (or if no results and console primary) ---")
                       if not results and args.output_format == 'console':
                           print("No matches found for your query.")
                       else:
                           print(formatted_output) # Print the (potentially empty) formatted output
                   sys.exit(1)
           else: # Output to console
               if not results:
                   print("No matches found for your query.")
               else:
                   print(formatted_output)
           
           # Consider the overall exit strategy.
           # If no matches and outputting to console (no file specified), exiting 0 is fine.
           # If writing to a file, success (exit 0) means the file was written, even if empty.
           if not results and not args.output_file : # Original condition for this exit
                sys.exit(0)

           # If we reached here and an output file was specified, it means writing was successful.
           # If console output with results, that was also successful.
           # No explicit sys.exit(0) needed here if all paths lead to it or an error exit.
           ```
     4.  **Test:** Re-run Test Case SCH-015: `mcp-searcher search "nonexistent_term_xyz123" sample_project --output-format json --output-file no_results.json`. Verify `no_results.json` is created and contains `[]`.

## 4. General Debugging Tools & Strategy
- **Iterative Testing:** After each targeted code change, re-run the specific test case(s) from `task_master_test_plan.txt` that failed due to the bug.
- **Python Debugger:** For complex flow or state issues, consider using `pdb` or your IDE's debugger.
  - Example: `python -m pdb src/mcp_searcher.py search "query" path --args...`
- **Focused Logging:** Instead of generic prints, use the `logging` module configured to output timestamps, module names, and log levels for more structured debugging information.
- **Clean Environment:** Ensure tests are run in the activated `venv_editable_test` virtual environment to reflect local code changes immediately.
- **Version Control:** Commit fixes individually with clear messages referencing the bug ID.

## 5. Verification
- After all high-priority bugs are addressed, consider re-running a larger subset or all relevant test cases from `task_master_test_plan.txt` to check for regressions.
- Update `potential_bugs_log.txt` and `task_master_test_plan.txt` as bugs are fixed.

This structured approach should help in efficiently identifying and resolving the current issues. 